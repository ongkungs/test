<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smooth Drop Stealth Integration</title>
  <style>
    :root {
      --bg: #000;
      --grid-init: #050505;
      --grid-border: #0a0a0a;

      /* END COLOR (Pure Black) */
      --match-color: #000000;
      --match-border: #0a0a0a;
      /* Updated to match --grid-border exactly */

      /* START COLOR (Gray) */
      --cube-start: #141414;
      --size: 64px;
      --radius: 10px;
      --gap: 4px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--bg);
    }

    body {
      margin: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: var(--bg);
      overflow: hidden;
      perspective: 1500px;
    }

    #grid {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) translateZ(-40px);
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--size));
      grid-template-rows: repeat(var(--rows), var(--size));
      gap: var(--gap);
      z-index: 10;
      /* Elevated to stay above the merged cube */
      transform-style: preserve-3d;
      contain: paint;
    }

    .tile {
      width: var(--size);
      height: var(--size);
      background: var(--grid-init);
      border: 1px solid var(--grid-border);
      box-sizing: border-box;
      border-radius: var(--radius);
      opacity: 0.2;
      will-change: transform, opacity;
      /* Boost performance */
      backface-visibility: hidden;
      transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275),
        background 0.4s ease,
        border-color 0.4s ease;
    }

    .hover-ready .tile:hover {
      transform: translateZ(15px) scale(1.02);
      background: #0d0d0d !important;
      border-color: #222 !important;
      opacity: 1 !important;
      cursor: pointer;
    }

    .hover-ready .layer div:hover {
      background: #1a1a1a !important;
      border-color: #333 !important;
      cursor: pointer;
      transform: translateZ(2px);
    }

    /* Wave trigger: Instant parent class update + CSS variable stagger */
    #grid.shockwave-active .tile {
      animation: tileRise 1.8s cubic-bezier(0.34, 1.56, 0.64, 1) var(--d) forwards;
    }

    @keyframes tileRise {
      0% {
        transform: translateZ(0);
        opacity: 0.2;
        background: var(--grid-init);
      }

      15% {
        transform: translateZ(75px);
        /* Higher overshoot for the bloom */
        background: #444;
        /* Pronounced grey blink */
        opacity: 1;
        border-color: #666;
      }

      40% {
        background: #111;
        /* Settle back towards dark */
      }

      100% {
        transform: translateZ(40px);
        background: var(--match-color);
        opacity: 1;
        border-color: var(--match-border);
      }
    }

    @keyframes textBloom {
      0% {
        opacity: 0;
        transform: translateZ(0) scale(0.9);
        background: #000;
        border-color: #050505;
      }

      30% {
        opacity: 1;
        transform: translateZ(55px) scale(1.02);
        background: #1a1a1a;
        /* Subtle peak brightness */
        border-color: #333;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.03);
      }

      100% {
        opacity: 1;
        transform: translateZ(50px) scale(1);
        background: #0d0d0d;
        border-color: #313131;
        box-shadow: none;
      }
    }

    /* Pixel Text Effect */
    #grid .tile.text-active {
      animation: textBloom 2.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards !important;
      z-index: 100 !important;
      opacity: 1 !important;
    }

    .hover-ready .tile.text-active:hover {
      background: #141414 !important;
      border-color: #333 !important;
      opacity: 1 !important;
      transform: translateZ(70px) scale(1.1) !important;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);
    }

    .cube-container {
      position: absolute;
      z-index: 100;
      width: calc(var(--size) * 3 + (var(--gap) * 2));
      height: calc(var(--size) * 3 + (var(--gap) * 2));
      transform-style: preserve-3d;
      transform: scale(2.2);
      will-change: transform;
      animation: dropAndImpact 1s cubic-bezier(0.8, 0, 1, 1) 2.4s forwards;
      transition: transform 1.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 1.2s ease;
    }

    /* Sink behind grid after impact as requested */
    .cube-container.merged {
      transform: scale(1) translateZ(-200px) !important;
      opacity: 0.1;
      /* More transparent to stay out of the way */
      filter: blur(8px);
      pointer-events: none;
      z-index: 0;
      /* Move behind the grid */
    }

    .layer {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: var(--gap);
      transform-style: preserve-3d;
    }

    .layer div {
      border-radius: var(--radius);
      box-sizing: border-box;
      border: 1px solid #222;
      background: var(--cube-start);
      will-change: transform, background;
      backface-visibility: hidden;
      /* SYNCED COLOR CHANGE */
      transition: background 1s cubic-bezier(0.8, 0, 1, 1),
        border-color 1s cubic-bezier(0.8, 0, 1, 1);
    }

    /* Sink Transition: Cube darkens and thins out during the fall to match the grid's starting look */
    .dropping .layer div {
      background: var(--grid-init);
      border-color: var(--grid-border);
    }

    .back-layer {
      --z: -12px;
      transform: translateZ(var(--z));
      filter: brightness(0.3);
      animation: rotateFull 2s cubic-bezier(0.65, 0, 0.35, 1) 0.3s forwards;
    }

    .middle-layer {
      --z: 0px;
      transform: translateZ(var(--z));
      filter: brightness(0.6);
      animation: rotateFull 2s cubic-bezier(0.65, 0, 0.35, 1) 0.15s forwards;
    }

    .front-layer {
      --z: 12px;
      transform: translateZ(var(--z));
      animation: rotateFull 2s cubic-bezier(0.65, 0, 0.35, 1) 0s forwards;
    }

    /* Impact Trigger (3.5s): The cube joins the energy wave */
    .merged .layer div {
      animation: cubeImpactFlare 1.8s cubic-bezier(0.34, 1.56, 0.64, 1) 150ms forwards;
      box-shadow: none;
      transform-origin: center center;
    }

    /* Flatten all layers into the integrated plane */
    .merged .front-layer {
      transform: translateZ(0px) rotate(360deg) !important;
    }

    .merged .middle-layer,
    .merged .back-layer {
      display: none;
    }

    @keyframes rotateFull {
      0% {
        transform: translateZ(var(--z, 0px)) rotate(0deg);
      }

      100% {
        transform: translateZ(var(--z, 0px)) rotate(360deg);
      }
    }

    @keyframes dropAndImpact {
      0% {
        transform: scale(2.2);
      }

      73% {
        transform: scale(1) translateZ(0);
      }

      85% {
        transform: scale(0.97) translateZ(-5px);
      }

      100% {
        transform: scale(1) translateZ(0);
      }
    }

    /* Synchronized color flare for the cube to match center tiles */
    @keyframes cubeImpactFlare {
      0% {
        background: var(--grid-init);
        border-color: var(--grid-border);
      }

      15% {
        background: #444;
        /* Match the shockwave's grey blink peak */
        border-color: #666;
      }

      40% {
        background: #111;
        /* Match the settle phase */
      }

      100% {
        background: var(--match-color);
        border-color: var(--match-border);
      }
    }
  </style>
</head>

<body>

  <div id="grid"></div>

  <div class="cube-container" id="cube">
    <!-- 3 Layers of 9 cubies each -->
    <div class="layer back-layer">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>
    <div class="layer middle-layer">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>
    <div class="layer front-layer">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>
  </div>

  <script>
    const grid = document.getElementById('grid');
    const cube = document.getElementById('cube');
    const tileDim = 68;
    let cols, rows;

    function init() {
      // Add buffer to ensure it exceeds screen size for all resolutions
      cols = Math.ceil(window.innerWidth / tileDim) + 4;
      if (cols % 2 === 0) cols++;
      rows = Math.ceil(window.innerHeight / tileDim) + 4;
      if (rows % 2 === 0) rows++;

      document.documentElement.style.setProperty('--cols', cols);
      document.documentElement.style.setProperty('--rows', rows);

      const centerX = Math.floor(cols / 2);
      const centerY = Math.floor(rows / 2);

      const fragment = document.createDocumentFragment();
      for (let i = 0; i < cols * rows; i++) {
        const x = i % cols;
        const y = Math.floor(i / cols);
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

        const tile = document.createElement('div');
        tile.className = 'tile';

        // Stagger logic for 60fps performance
        const delay = (distance - 1.5) * 0.07 + 0.1; // 100ms impact delay
        tile.style.setProperty('--d', `${delay.toFixed(3)}s`);

        fragment.appendChild(tile);
      }
      grid.innerHTML = '';
      grid.appendChild(fragment);

      setTimeout(() => cube.classList.add('dropping'), 2400);
      setTimeout(triggerImpact, 3500);
    }

    function triggerImpact() {
      cube.classList.add('merged');
      // Instant trigger: Browser handles the stagger via the --d CSS variable.
      grid.classList.add('shockwave-active');

      // Enable hover effects and text reveal after shockwave settles (1.8s) + a 1s delay
      setTimeout(() => {
        document.body.classList.add('hover-ready');
        showPixelText();
      }, 2000);
    }

    function showPixelText() {
      const tiles = document.querySelectorAll('.tile');

      // 3x5 Pixel Font for "ONGKUNG"
      const chars = {
        'O': [[0, 0], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [2, 2], [0, 3], [2, 3], [0, 4], [1, 4], [2, 4]],
        'N': [[0, 0], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [2, 2], [0, 3], [2, 3], [0, 4], [2, 4]],
        'G': [[0, 0], [1, 0], [2, 0], [0, 1], [0, 2], [2, 2], [0, 3], [2, 3], [0, 4], [1, 4], [2, 4]],
        'K': [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 2], [2, 0], [2, 1], [2, 3], [2, 4]],
        'U': [[0, 0], [0, 1], [0, 2], [0, 3], [2, 0], [2, 1], [2, 2], [2, 3], [0, 4], [1, 4], [2, 4]],
      };

      const word = "ONGKUNG";
      const startX = Math.floor((cols - (word.length * 4 - 1)) / 2);
      const startY = Math.floor((rows - 5) / 2); // Perfectly centered vertically

      word.split('').forEach((char, index) => {
        const charMap = chars[char];
        const offset = index * 4;

        charMap.forEach(([px, py]) => {
          const gridX = startX + offset + px;
          const gridY = startY + py;

          if (gridX >= 0 && gridX < cols && gridY >= 0 && gridY < rows) {
            const tileIndex = gridY * cols + gridX;
            if (tiles[tileIndex]) {
              const diagonalIndex = (offset + px) + (4 - py); // diagonal from bottom-left
              setTimeout(() => {
                tiles[tileIndex].classList.add('text-active');
              }, 500 + (diagonalIndex * 60));
            }
          }
        });
      });
    }

    init();
    window.addEventListener('resize', () => location.reload());
  </script>
</body>

</html>
