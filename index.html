<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Smooth Drop Stealth Integration</title>
  <style>
    :root {
      --bg: #000;
      --grid-init: #050505;
      --grid-border: #0a0a0a;
      --match-color: #000000;
      --match-border: #141414;
      --cube-start: #141414;
      /* Optimize for performance: larger tiles on mobile = fewer elements */
      --size: clamp(32px, 8vw, 64px);
      --radius: clamp(4px, 1.5vw, 8px);
      --gap: clamp(2px, 0.5vw, 4px);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--bg);
    }

    body {
      margin: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: var(--bg);
      overflow: hidden;
      perspective: 1500px;
    }



    #grid {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate3d(-50%, -50%, -40px);
      display: grid;
      grid-template-columns: repeat(var(--cols), var(--size));
      grid-template-rows: repeat(var(--rows), var(--size));
      gap: var(--gap);
      z-index: 10;
      transform-style: preserve-3d;
      contain: paint;
    }

    .tile {
      width: var(--size);
      height: var(--size);
      background: var(--grid-init);
      border: 1px solid var(--grid-border);
      box-sizing: border-box;
      border-radius: var(--radius);
      opacity: 0.2;
      will-change: transform, opacity;
      /* Boost performance */
      backface-visibility: hidden;
      transform: translate3d(0, 0, 0);
      /* Force Hardware Acceleration */
      transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275),
        background 0.4s ease,
        border-color 0.4s ease;
    }

    .hover-ready .tile:hover {
      transform: translateZ(15px) scale(1.02);
      background: #0d0d0d !important;
      border-color: #222 !important;
      opacity: 1 !important;
      cursor: pointer;
    }

    .hover-ready .layer div:hover {
      background: #1a1a1a !important;
      border-color: #333 !important;
      cursor: pointer;
      transform: translateZ(2px);
    }

    /* Wave trigger: Instant parent class update + CSS variable stagger */
    #grid.shockwave-active .tile {
      animation: tileRise 1.8s cubic-bezier(0.34, 1.56, 0.64, 1) var(--d) forwards;
    }

    @keyframes tileRise {
      0% {
        transform: translate3d(0, 0, 0);
        opacity: 0.2;
        background: var(--grid-init);
      }

      15% {
        transform: translate3d(0, 0, 75px);
        background: #444;
        opacity: 1;
        border-color: #666;
      }

      40% {
        background: #111;
      }

      100% {
        transform: translate3d(0, 0, 40px);
        background: var(--match-color);
        opacity: 1;
        border-color: var(--match-border);
      }
    }

    /* Lighter animation for mobile */
    .mobile-perf .tile {
      animation-duration: 1.2s !important;
    }

    .mobile-perf .tileRise {
      transform: translateZ(40px) !important;
    }

    @keyframes textBloom {
      0% {
        opacity: 0;
        transform: translateZ(0) scale(0.9);
        background: #000;
        border-color: #050505;
      }

      30% {
        opacity: 1;
        transform: translateZ(55px) scale(1.02);
        background: #1a1a1a;
        /* Subtle peak brightness */
        border-color: #333;
        box-shadow: 0 0 8px rgba(255, 255, 255, 0.03);
      }

      100% {
        opacity: 1;
        transform: translateZ(50px) scale(1);
        background: #bbbbbb;
        border-color: #646464;
        box-shadow: none;
      }
    }

    /* Pixel Text Effect */
    #grid .tile.text-active {
      animation: textBloom 2.5s cubic-bezier(0.2, 0.8, 0.2, 1) forwards !important;
      z-index: 100 !important;
      opacity: 1 !important;
    }

    .hover-ready .tile.text-active:hover {
      background: #141414 !important;
      border-color: #333 !important;
      opacity: 1 !important;
      transform: translateZ(70px) scale(1.1) !important;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.05);
    }

    .cube-container {
      position: absolute;
      z-index: 100;
      width: calc(var(--size) * 3 + (var(--gap) * 2));
      height: calc(var(--size) * 3 + (var(--gap) * 2));
      transform-style: preserve-3d;
      transform: scale(min(2.2, 35vw / 12px));
      /* Match cube to screen */
      will-change: transform;
      animation: dropAndImpact 1s cubic-bezier(0.8, 0, 1, 1) 2.4s forwards;
      transition: transform 1.2s cubic-bezier(0.4, 0, 0.2, 1), opacity 1.2s ease;
    }

    /* Sink behind grid after impact as requested */
    .cube-container.merged {
      transform: scale(min(0.5, 20vw / 12px)) translateZ(-200px) !important;
      opacity: 0.1;
      filter: blur(8px);
      pointer-events: none;
      z-index: 0;
    }

    .layer {
      position: absolute;
      inset: 0;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: var(--gap);
      transform-style: preserve-3d;
    }

    .layer div {
      border-radius: var(--radius);
      box-sizing: border-box;
      border: 1px solid #222;
      background: var(--cube-start);
      will-change: transform, background;
      backface-visibility: hidden;
      /* SYNCED COLOR CHANGE */
      transition: background 1s cubic-bezier(0.8, 0, 1, 1),
        border-color 1s cubic-bezier(0.8, 0, 1, 1);
    }

    /* Sink Transition: Cube darkens and thins out during the fall to match the grid's starting look */
    .dropping .layer div {
      background: var(--grid-init);
      border-color: var(--grid-border);
    }

    .back-layer {
      --z: -12px;
      transform: translateZ(var(--z));
      filter: brightness(0.3);
      animation: rotateFull 2s cubic-bezier(0.65, 0, 0.35, 1) 0.3s forwards;
    }

    .middle-layer {
      --z: 0px;
      transform: translateZ(var(--z));
      filter: brightness(0.6);
      animation: rotateFull 2s cubic-bezier(0.65, 0, 0.35, 1) 0.15s forwards;
    }

    .front-layer {
      --z: 12px;
      transform: translateZ(var(--z));
      animation: rotateFull 2s cubic-bezier(0.65, 0, 0.35, 1) 0s forwards;
    }

    /* Impact Trigger (3.5s): The cube joins the energy wave */
    .merged .layer div {
      animation: cubeImpactFlare 1.8s cubic-bezier(0.34, 1.56, 0.64, 1) 150ms forwards;
      box-shadow: none;
      transform-origin: center center;
    }

    /* Flatten all layers into the integrated plane */
    .merged .front-layer {
      transform: translateZ(0px) rotate(360deg) !important;
    }

    .merged .middle-layer,
    .merged .back-layer {
      display: none;
    }

    @keyframes rotateFull {
      0% {
        transform: translateZ(var(--z, 0px)) rotate(0deg);
      }

      100% {
        transform: translateZ(var(--z, 0px)) rotate(360deg);
      }
    }

    @keyframes dropAndImpact {
      0% {
        transform: scale(2.2);
      }

      73% {
        transform: scale(1) translateZ(0);
      }

      85% {
        transform: scale(0.97) translateZ(-5px);
      }

      100% {
        transform: scale(1) translateZ(0);
      }
    }

    /* Synchronized color flare for the cube to match center tiles */
    @keyframes cubeImpactFlare {
      0% {
        background: var(--grid-init);
        border-color: var(--grid-border);
      }

      15% {
        background: #444;
        /* Match the shockwave's grey blink peak */
        border-color: #666;
      }

      40% {
        background: #111;
        /* Match the settle phase */
      }

      100% {
        background: var(--match-color);
        border-color: var(--match-border);
      }
    }
  </style>
</head>

<body>

  <div id="grid"></div>

  <div class="cube-container" id="cube">
    <!-- 3 Layers of 9 cubies each -->
    <div class="layer back-layer">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>
    <div class="layer middle-layer">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>
    <div class="layer front-layer">
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
      <div></div>
    </div>
  </div>

  <script>
    const grid = document.getElementById('grid');
    const cube = document.getElementById('cube');
    let cols, rows;

    function init() {
      // Get computed tile size including gap
      const temp = document.createElement('div');
      temp.style.width = 'var(--size)';
      temp.style.marginLeft = 'var(--gap)';
      document.body.appendChild(temp);
      const tileTotal = temp.offsetWidth + parseFloat(getComputedStyle(temp).marginLeft);
      document.body.removeChild(temp);

      const isMobile = window.innerWidth < 768;
      const buffer = isMobile ? 0 : 2;
      const calcMethod = isMobile ? Math.floor : Math.ceil;

      cols = calcMethod(window.innerWidth / tileTotal) + buffer;
      if (cols % 2 === 0) cols++;
      rows = calcMethod(window.innerHeight / tileTotal) + buffer;
      if (rows % 2 === 0) rows++;

      if (isMobile) {
        document.body.classList.add('mobile-perf');
      }

      document.documentElement.style.setProperty('--cols', cols);
      document.documentElement.style.setProperty('--rows', rows);

      const centerX = Math.floor(cols / 2);
      const centerY = Math.floor(rows / 2);

      const fragment = document.createDocumentFragment();

      // On mobile, use a lighter staggering to save CPU
      const staggerFactor = isMobile ? 0.04 : 0.07;

      for (let i = 0; i < cols * rows; i++) {
        const x = i % cols;
        const y = Math.floor(i / cols);
        const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

        const tile = document.createElement('div');
        tile.className = 'tile';

        const delay = (distance - 1.5) * staggerFactor + 0.1;
        tile.style.setProperty('--d', `${delay.toFixed(3)}s`);

        fragment.appendChild(tile);
      }
      grid.innerHTML = '';
      grid.appendChild(fragment);


      setTimeout(() => cube.classList.add('dropping'), 2400);
      setTimeout(triggerImpact, 3500);
    }

    function triggerImpact() {
      cube.classList.add('merged');
      // Instant trigger: Browser handles the stagger via the --d CSS variable.
      grid.classList.add('shockwave-active');

      // Enable hover effects and text reveal after shockwave settles (1.8s) + a 1s delay
      setTimeout(() => {
        document.body.classList.add('hover-ready');
        showPixelText();
      }, 2000);
    }

    function showPixelText() {
      const tiles = document.querySelectorAll('.tile');
      const chars = {
        'O': [[0, 0], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [2, 2], [0, 3], [2, 3], [0, 4], [1, 4], [2, 4]],
        'N': [[0, 0], [1, 0], [2, 0], [0, 1], [2, 1], [0, 2], [2, 2], [0, 3], [2, 3], [0, 4], [2, 4]],
        'G': [[0, 0], [1, 0], [2, 0], [0, 1], [0, 2], [2, 2], [0, 3], [2, 3], [0, 4], [1, 4], [2, 4]],
        'K': [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [1, 2], [2, 0], [2, 1], [2, 3], [2, 4]],
        'U': [[0, 0], [0, 1], [0, 2], [0, 3], [2, 0], [2, 1], [2, 2], [2, 3], [0, 4], [1, 4], [2, 4]],
      };

      const isSmall = window.innerWidth < 900;
      const lines = isSmall ? ["ONG", "KUNG"] : ["ONGKUNG"];

      lines.forEach((word, lineIndex) => {
        const lineOffset = isSmall ? (lineIndex * 7) : 0;
        const totalLinePixels = word.length * 4 - 1;
        const startX = Math.floor((cols - totalLinePixels) / 2);
        const startY = Math.floor((rows - (isSmall ? 12 : 5)) / 2) + lineOffset;

        word.split('').forEach((char, charIdx) => {
          const charMap = chars[char];
          const xOffset = charIdx * 4;

          charMap.forEach(([px, py]) => {
            const gridX = startX + xOffset + px;
            const gridY = startY + py;

            if (gridX >= 0 && gridX < cols && gridY >= 0 && gridY < rows) {
              const tileIndex = gridY * cols + gridX;
              if (tiles[tileIndex]) {
                const diagonalIndex = (charIdx * 4 + px) + (lineIndex * 7) + (4 - py);
                setTimeout(() => {
                  tiles[tileIndex].classList.add('text-active');
                }, 500 + (diagonalIndex * 60));
              }
            }
          });
        });
      });
    }


    init();
    window.addEventListener('resize', () => location.reload());
  </script>
</body>

</html>
